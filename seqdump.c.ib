#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <getopt.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>

#include <sqlite3.h>
#include <plist/plist.h>

#define VERSION "0.1"
/*
	seqdump
	
	TODO:
		- non-dm groups
		
*/

#include "html.h"

int dump(const char * source, const char * output, const bool list, const char * groups, const char * nnumber)

void sql_error(sqlite3 * db, const char * part)
	fprintf(stderr, "failed at %s", part)
	sqlite3_close(db)
	exit(1)

static void help(void)
	puts("Usage seqdump: -s [DATABASE] -o [OUTPUT] \n\n" \
		"A tool for dumping Signal history from the iOS database.\n" \
		"\n" \
		" -h --help      -> print this page\n" \
		" -V --version   -> show current version\n" \
		" -s --sql       -> define sql database\n" \
		" -o --output    -> define output\n" \
		" -l --list      -> list rooms\n" \
		" -g --groups    -> define groups to dump\n")

int main(const int argc, char ** argv)
	const char * short_options = "hVs:o:c:ln::g:a:"
	const struct option long_option[] =
			"help",         no_argument,       0, 'h'
		
			"version",      no_argument,       0, 'V'
		
			"sql",          required_argument, 0, 's'
		
			"output",       required_argument, 0, 'o'
		
			"list",         no_argument,       0, 'l'
		
			"number",       optional_argument, 0, 'n'
		
			"groups",       required_argument, 0, 'g'
		
			0, 0, 0, 0
	
	char * output = NULL
	char * source = NULL
	char * groups = NULL
	char * number = NULL
	bool   list   = false
	
	while (1)
		const int opt = getopt_long(argc, argv, short_options, long_option, NULL)
		if (opt == -1) break
		switch (opt)
			default:
			case '?':
				fprintf(stderr, "invalid option %c\n", opt)
				return 1
			case 'h':
				help()
				return 0
			case 'V':
				fputs("seqdump version "VERSION"\n", stdout)
				return 0
			case 's':
				source = optarg
				continue
			case 'o':
				output = optarg
				continue
			case 'l':
				list = true
				continue
			case 'n':
				if (optarg != NULL)
					if (*optarg == '=')
						number = optarg + 1
					else
						number = optarg
				else
					number = (char *) 1
				continue
			case 'g':
				groups = optarg
				continue
	
	if (source == NULL)
		help()
		return 1
	
	dump(source, output, list, groups, number)

const char * lookup(const char ** table, const char * key, const size_t limit)
	size_t lookupn = 0
	while (1)
		if (strcmp(table[lookupn + 1], key) == 0)
			return table[lookupn]
			break
		lookupn += 2
		if (lookupn >= limit)
			break
	return NULL

// parser for attachement uuids hidden in plists
// this is a strong bodge but its performant and simple
const size_t uuid_plister(char *** dest, const char * plist, const char * plist_end)
	size_t count = 0
	size_t last_malloc = 10
	while (plist + 37 <= plist_end)
		if (*plist == '$' && *(plist + 9) == '-')
			if (!count)
				*dest = malloc(10 * sizeof(char *))
			else if (last_malloc <= count)
				*dest = realloc(*dest, (count + 10) * sizeof(char *))
				last_malloc += 10
			(*dest)[count] = malloc(40 * sizeof(char))
			bzero((*dest)[count], 40)
			strncpy((*dest)[count], plist + 1, 36)
			count++
			plist += 35
		plist++
	return count

void attach_lookup(char ** dest, char * key, sqlite3 * db)
	sqlite3_stmt * stmtu = NULL
	if ((sqlite3_prepare_v2(db, "SELECT localRelativeFilePath FROM model_TSAttachment WHERE uniqueId = ?;", -1, &stmtu, NULL)) != SQLITE_OK)
		sql_error(db, "Attachment table")
	if (sqlite3_bind_text(stmtu, 1, key, -1, SQLITE_TRANSIENT) != SQLITE_OK)
		sql_error(db, "Attachment table")
	if (sqlite3_step(stmtu) == SQLITE_ROW)
		const char * path = sqlite3_column_text(stmtu, 0)
		if (path)
			const size_t path_l = strlen(path)
			*dest = malloc((path_l + 1) * sizeof(char))
			strcpy(*dest, path + 1)
	sqlite3_finalize(stmtu)

// parser for quoted messages hidden in plists
const size_t quote_plister(char ** dest, const char * plist_buf, size_t plist_size, sqlite3 * db)
	size_t count = 0
	plist_t plist = NULL
	plist_format_t form = PLIST_FORMAT_BINARY
	plist_from_memory(plist_buf, plist_size, &plist, &form)
	
	if (plist == NULL || plist_get_node_type(plist) != PLIST_DICT)
		return 0
	
	plist_dict_iter iter = NULL
	plist_dict_new_iter(plist, &iter)
	
	while (1)
		plist_t value
		plist_dict_next_item(plist, iter, NULL, &value)
		
		if (!value)
			break
		
		if (plist_get_node_type(value) != PLIST_ARRAY)
			continue
		
		plist_array_iter aiter = NULL
		plist_array_new_iter(value, &aiter)
		size_t str_c = 0
		bool attach = false
		bool dict_checked = false
		while (1)
			plist_t avalue
			plist_array_next_item(value, aiter, &avalue)
			
			if (!avalue) break
			
			if (!dict_checked && plist_get_node_type(avalue) == PLIST_DICT)
				plist_dict_iter diter = NULL
				plist_dict_new_iter(avalue, &diter)
				plist_t dkey
				plist_dict_next_item(avalue, diter, NULL, &dkey)
				plist_t dkeyn
				plist_dict_next_item(avalue, diter, NULL, &dkeyn)
				char * dkeys
				plist_dict_get_item_key(dkeyn, &dkeys)
				if (strcmp(dkeys, "quotedAttachment") == 0)
					attach = true
				plist_mem_free(dkeys)
				free(diter)
				dict_checked = true
			else if (plist_get_node_type(avalue) == PLIST_STRING)
				if (str_c == 1)
					if (!attach)
						char * str
						plist_get_string_val(avalue, &str)
						const size_t str_l = strlen(str)
						if (str)
							*dest = malloc((str_l + 1) * sizeof(char))
							strcpy(*dest, str)
							plist_mem_free(str)
							count++
					else
						char * str
						plist_get_string_val(avalue, &str)
						char * path = NULL
						attach_lookup(&path, str, db)
						plist_mem_free(str)
						if (path)
							*dest = malloc((strlen(path) + 12) * sizeof(char))
							sprintf(*dest, "attachment: %s", path)
							free(path)
							count++
					break
				str_c++
		free(aiter)
		if (count) 
			break
	
	free(iter)
	plist_free(plist)
	return count

int dump(const char * source, const char * output, const bool list, const char * groups, const char * nnumber)
	int out_fd = 1
	if (output != NULL)
		out_fd = open(output, O_WRONLY | O_CREAT, 0644)
	
	sqlite3 * db
	if ((sqlite3_open(source, &db)) != SQLITE_OK)
		fprintf(stderr, "Error opening db\n")
		return 1
	
	// get profile phone number
	// I decided to just take the first Recipients phone number
	sqlite3_stmt * an_stmt = NULL
	char * acc_number = NULL
	if (sqlite3_prepare_v2(db, "SELECT recipientPhoneNumber FROM model_SignalRecipient WHERE id = 1;", -1, &an_stmt, NULL) != SQLITE_OK)
		sql_error(db, "Account Phone number")
	if (sqlite3_step(an_stmt) == SQLITE_ROW)
		const char * num = sqlite3_column_text(an_stmt, 0)
		const size_t num_l = strlen(num)
		acc_number = malloc((num_l + 1) * sizeof(char))
		strcpy(acc_number, num)
	else
		sql_error(db, "Account Phone number")
	sqlite3_finalize(an_stmt)
	
	
	// create profile lookup table
	// allowing you to find the name of the sender of a message
	// and looking up the name associated with a dm group
	sqlite3_stmt * pft_stmt
	if (sqlite3_prepare_v2(db, "SELECT profileName, recipientPhoneNumber FROM model_OWSUserProfile;", -1, &pft_stmt, NULL) != SQLITE_OK)
		sql_error(db, "Profile Table")
	char ** name_table = malloc(10 * sizeof(char *))
	size_t name_table_pos = 0
	size_t name_table_last_malloc = 0
	while (sqlite3_step(pft_stmt) == SQLITE_ROW)
		if (sqlite3_column_type(pft_stmt, 0) != SQLITE_NULL && (sqlite3_column_type(pft_stmt, 1) != SQLITE_NULL || name_table_pos == 0))
			const unsigned char * name = sqlite3_column_text(pft_stmt, 0)
			unsigned char * number = NULL
			if (name_table_last_malloc + 10 <= name_table_pos)
				name_table = realloc(name_table, (name_table_pos + 10) * sizeof(char *))
				name_table_last_malloc += 10
			name_table[name_table_pos] = malloc(64)
			name_table[name_table_pos + 1] = malloc(64)
			if (name_table_pos == 0)
				number = acc_number
			else
				number = (unsigned char *) sqlite3_column_text(pft_stmt, 1)
			if ((nnumber > (char *) 1 && strcmp(name, nnumber) == 0) || nnumber == (char *) 1)
				dprintf(out_fd, "%s: %s\n", name, number)
			strcpy(name_table[name_table_pos], name)
			strcpy(name_table[name_table_pos + 1], number)
			name_table_pos += 2
	sqlite3_finalize(pft_stmt)
	
	// create group lookup table
	// allowing you to associate messages with group names
	sqlite3_stmt * gt_stmt = NULL
	if (sqlite3_prepare_v2(db, "SELECT uniqueId, contactPhoneNumber FROM model_TSThread;", -1, &gt_stmt, NULL) != SQLITE_OK)
		sql_error(db, "Group Table\n")
	char ** group_table = malloc(10 * sizeof(char *))
	size_t group_table_pos = 0
	size_t group_table_last_malloc = 0
	while (sqlite3_step(gt_stmt) == SQLITE_ROW)
		if (sqlite3_column_type(gt_stmt, 0) != SQLITE_NULL && sqlite3_column_type(gt_stmt, 1) != SQLITE_NULL )
			const unsigned char * group_id = sqlite3_column_text(gt_stmt, 0)
			const unsigned char * number = sqlite3_column_text(gt_stmt, 1)
			const char * name = lookup((const char **) name_table, number, name_table_pos)
			if (name)
				if (list)
					dprintf(out_fd, "%s\n", name)
					continue
				if (group_table_last_malloc + 10 <= group_table_pos)
					group_table = realloc(group_table, (group_table_pos + 10) * sizeof(char *))
					group_table_last_malloc += 10
				group_table[group_table_pos] = malloc(64)
				group_table[group_table_pos + 1] = malloc(64)
				strcpy(group_table[group_table_pos], name)
				strcpy(group_table[group_table_pos + 1], group_id)
				group_table_pos += 2
	sqlite3_finalize(gt_stmt)
	
	if (list || nnumber != NULL || nnumber == (char *) 1)
		goto close
	
	dprintf(out_fd, "%s\n", html_header)
	
	// loops over all entries of the interaction table and prints them accordingly
	sqlite3_stmt * stmt
	if ((sqlite3_prepare_v2(db, "SELECT body, uniqueThreadId, authorPhoneNumber, timestamp, callType, attachmentIds, quotedMessage FROM model_TSInteraction;", -1, &stmt, NULL)) != SQLITE_OK)
		sql_error(db, "Interaction table")
	
	char * last_num = malloc(32)
	last_num[0] = '\0'
	const time_t unixstart = 0
	struct tm tm_info = *gmtime(&unixstart)
	while (sqlite3_step(stmt) == SQLITE_ROW)
		const int type = (sqlite3_column_type(stmt, 0) != SQLITE_NULL) ? 1 : \
		                 (sqlite3_column_type(stmt, 4) != SQLITE_NULL) ? 2 : \
		                 (sqlite3_column_type(stmt, 5) != SQLITE_NULL) ? 3 : 0
		
		if (!type)
			continue
		const unsigned char * thread = sqlite3_column_text(stmt, 1)
		const unsigned char * group = lookup((const char **) group_table, thread, group_table_pos)
		
		if (!(!groups) && (!group || strcmp(group, groups) != 0))
			continue
		const time_t timestamp = sqlite3_column_int64(stmt, 3) / 1000
		
		bool you = false, same = false
		unsigned char * author = NULL
		// small hack - the authorPhoneNumber is Null if its from you
		if (sqlite3_column_type(stmt, 2) == SQLITE_NULL)
			author = acc_number
			you = true
		else
			author = (char *) sqlite3_column_text(stmt, 2)
		
		if (strcmp(author, last_num) == 0)
			same = true
		else
			strcpy(last_num, author)
		
		const unsigned char * name = lookup((const char **) name_table, author, name_table_pos)
		
		if (sqlite3_column_type(stmt, 5) != SQLITE_NULL)
			const void * blob_data = sqlite3_column_blob(stmt, 5)
			const size_t blob_size = sqlite3_column_bytes(stmt, 5)
			char ** uuids = NULL
			size_t uuidc = uuid_plister(&uuids, blob_data, blob_data + blob_size)
			if (!uuidc && type == 3)
				continue
			while (uuidc)
				--uuidc
				char * path =NULL
				attach_lookup(&path, uuids[uuidc], db)
				free(uuids[uuidc])
				if (path)
					dprintf(out_fd, html_image, same ? "message-nonbreak" : "message-break", you ? "right" : "left", path)
				free(path)
				if (!uuidc)
					free(uuids)
		if (sqlite3_column_type(stmt, 6) != SQLITE_NULL)
			const void * blob_data = sqlite3_column_blob(stmt, 6)
			const size_t blob_size = sqlite3_column_bytes(stmt, 6)
			char * quote = NULL
			if (quote_plister(&quote, blob_data, blob_size, db) && quote)
				//dprintf(out_fd, "<\"%s\">\n\t", quote)
				free(quote)
		
		
		char buffer[30]
		const struct tm tm_info_tmp = *gmtime((time_t *) &timestamp)
		if (tm_info.tm_yday != tm_info_tmp.tm_yday)
			strftime(buffer, 30, "%e, %b %Y", &tm_info_tmp)
			dprintf(out_fd, html_dater, buffer)
		tm_info = tm_info_tmp
		strftime(buffer, 30, "%H:%M", &tm_info)
		if (type == 1)
			// print message
			const unsigned char * body = sqlite3_column_text(stmt, 0)
			//dprintf(out_fd, "%s [ %s ] :\n\t", buffer, name)
			//dprintf(out_fd, "%s\n\n", body)
			dprintf(out_fd, html_message, same ? "message-nonbreak" : "message-break", you ? "right" : "left", body, buffer)
		else if (type == 2)
			// print call
			const unsigned int call = sqlite3_column_int64(stmt, 4)
			//dprintf(out_fd, "%s [ %s ] :\n\t", buffer, name)
			char calli[64]
			sprintf(calli, "%s voice call ", call == 2  ? "Outgoing" : \
			                                 call == 1  ? "Incoming" : \
			                                 call == 8  ? "Unanswered" : \
			                                 call == 12 ? "Missed call while on Do not disturb" : \
			                                 call == 7  ? "Declied" : \
			                                 call == 3  ? "Missed" : "")
			strcat(calli, "· ")
			strcat(calli, buffer)
			dprintf(out_fd, html_dater, calli)
		else if (type == 3)
	
	sqlite3_finalize(stmt)
	dprintf(out_fd, "%s\n", html_footer)
	
	if (last_num)
		free(last_num)
	
	close:
	sqlite3_close(db)
	
	
	
	// free name_table
	while (1)
		name_table_pos -= 2
		free(name_table[name_table_pos])
		free(name_table[name_table_pos + 1])
		if (name_table_pos <= 0)
			break
	free(name_table)
	
	// free group table (if needed)
	if (!list)
		while (1)
			group_table_pos -= 2
			free(group_table[group_table_pos])
			free(group_table[group_table_pos + 1])
			if (group_table_pos <= 0)
				break
		free(group_table)
	
	// free file if defined
	if (output != NULL)
		close(out_fd)
	
	if (acc_number)
		free(acc_number)
	
	return 0
